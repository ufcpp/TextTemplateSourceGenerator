using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;
using TextTemplateSourceGenerator.CSharp;
using TextTemplateSourceGenerator.Languages.TemplateA.Parser;

namespace TextTemplateSourceGenerator.Languages.TemplateA.Formatter;

public class SyntaxNodeFormatter
{
    public static string FormatClassMember(TypeDeclarationSyntax type, string template, int language)
    {
        var sb = new StringBuilder();
        sb.Append("""
            // <auto-generated/>
            #pragma warning disable 8019

            """);

        var n = AppendDeclarations(sb, type);

        var body = language switch
        {
            1 => RenderScriban(template),
            255 => RenderTemplateA(template),
            _ => template,
        };

        sb.Append(body);
        AppendClose(sb, n);

        return sb.ToString();
    }

    private static string RenderScriban(string template)
    {
        //todo: error handling
        var t = Scriban.Template.Parse(template);
        return t.Render();
    }

    private static string RenderTemplateA(string template)
    {
        var sb = new StringBuilder();
        TemplateFormatter.Format(sb, new(template), "_env.Append");
        var source = sb.ToString();

        //todo: error handling

        var runner = new Runner();
        var result = runner.Run(source);
        return result;
    }

    public static string FormatPreprocessorMethod(MethodDeclarationSyntax method, string template, string? appendMethodName)
    {
        var sb = new StringBuilder();
        sb.Append("""
            // <auto-generated/>
            #pragma warning disable 8019

            """);

        var n = AppendDeclarations(sb, (TypeDeclarationSyntax)method.Parent!);
        AppendMethodSignature(sb, method);
        AppendBody(sb, new(template), appendMethodName ?? "builder.Append");
        AppendClose(sb, n);

        return sb.ToString();
    }

    public static string Format(TypeDeclarationSyntax type, IEnumerable<MethodDeclarationSyntax> methods, Func<MemberDeclarationSyntax, (TemplateParser elements, string appendMethodName)> getSyntaxElements)
    {
        var sb = new StringBuilder();
        sb.Append("""
            // <auto-generated/>
            #pragma warning disable 8019

            """);

        var n = AppendDeclarations(sb, type);
        foreach (var m in methods)
        {
            AppendMethodSignature(sb, m);
            var (e, a) = getSyntaxElements(m);
            AppendBody(sb, e, a);
        }
        AppendClose(sb, n);

        return sb.ToString();
    }

    private static void AppendBody(StringBuilder sb, TemplateParser elements, string appendMethodName)
    {
        sb.Append("""

            {

            """);
        TemplateFormatter.Format(sb, elements, appendMethodName);

        sb.Append("""

            }

            """);
    }

    private static void AppendMethodSignature(StringBuilder sb, MethodDeclarationSyntax m)
    {
        foreach (var mod in m.Modifiers)
        {
            sb.Append(mod.Text);
            sb.Append(' ');
        }

        sb.Append(m.ReturnType);
        sb.Append(' ');

        sb.Append(m.Identifier.Text);

        sb.Append(m.ParameterList.ToFullString());
    }

    private static int AppendDeclarations(StringBuilder sb, SyntaxNode? node)
    {
        if (node is null) return 0;

        var nest = AppendDeclarations(sb, node.Parent);

        switch (node)
        {
            case CompilationUnitSyntax c:
                AppendUsings(sb, c);
                return nest;
            case BaseNamespaceDeclarationSyntax ns:
                AppendNamespaceOpen(sb, ns);
                return nest + 1;
            case TypeDeclarationSyntax t:
                AppendTypeOpen(sb, t);
                return nest + 1;
            default:
                return nest;
        }
    }

    private static void AppendTypeOpen(StringBuilder sb, TypeDeclarationSyntax t)
    {
        sb.Append("partial ");
        sb.Append(t.Keyword.Text);
        sb.Append(' ');
        sb.Append(t.Identifier.Text);

        if (t.TypeParameterList is { } tl)
        {
            sb.Append('<');
            var first = true;
            foreach (var tp in tl.Parameters)
            {
                if (first) first = false;
                else sb.Append(", ");
                sb.Append(tp.Identifier.Text);
            }
            sb.Append('>');
        }
        sb.Append("""
             {

            """);
    }

    private static void AppendNamespaceOpen(StringBuilder sb, BaseNamespaceDeclarationSyntax ns)
    {
        sb.Append($$"""
        namespace {{ns.Name}} {

        """);
    }

    private static void AppendUsings(StringBuilder sb, CompilationUnitSyntax c)
    {
        foreach (var u in c.Usings)
        {
            sb.Append(u.ToFullString());
        }
    }

    private static void AppendClose(StringBuilder sb, int nest)
    {
        for (int i = 0; i < nest; i++)
        {
            sb.Append('}');
        }
        sb.Append("""


            """);
    }
}
